---
title: "Statistical Methods"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Statistical Methods}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
editor_options: 
  markdown: 
    wrap: sentence
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Statistical method types in {chef}

{chef} supports 3 different types of statistical methods. They are differentiated by which inputs they are given and their place in the results table.

For statistical method in {chef}, we talk about _cell(s)_ which refer both to the location in the result table but more fundamentally to slicing of data relevant to the statistical method type. See more below.

### stat_by_strata_by_trt

Those statistics which describes the characteristics for a single stratum and single treatment arm.

The outputs of these functions are exemplified in the figure below in red. A single _cell_ denoting the output of the statistical function could be: total number of Females in TreatmentA = 120.

### stat_by_strata_across_trt 

Those statistics which describes a single stratum but across treatments arms.

The outputs of these functions are exemplified in green in the figure below. For instance one could run a Fischers exact test for 2x2 contigency table (TreatmentA/TreatmentB vs hasEvent/hasNotEvent) but only for Females and get the result of 0.003.

### stat_across_strata_across_trt

Defines those statistics which will test the interaction of strata with treatments.

The outputs of these functions are exemplified in blue in the figure below. For instance one could run a Breslow-Day test testing for effect of stratas (ie. Gender) on the 2x2 contingency tables.

```{r statDesc, echo=FALSE, out.width="100%"}
knitr::include_graphics("./figures/StatisticsDescription.png")
```




## Protocols for statistical functions.

The supplied inputs to statistical functions will vary dependent on the type and will be described in the following sections. The output however is the same for all statistical functions.

### Output specification (Shared for all types)

<table style = "width:30%; float:right; margin:20px;">
  <caption>*data.table multirow output*</caption>
  <colgroup>
    <col style="width:30%;">
    <col style="width:70%;">
  </colgroup>
    <thead>
      <td>label</td>
      <td>value</td>
      <td>description</td>
    </thead>
    <tbody>
        <tr>
            <td>N</td>
            <td>120</td>
            <td>Counts.</td>
        </tr>
        <tr>
            <td>n</td>
            <td>18</td>
            <td>Counts. with events.</td>
        </tr>
        <tr>
            <td>(%)</td>
            <td>15</td>
            <td>Rel. proportion</td>
        </tr>
    </tbody>
</table>

They must return a `data.table` object with 2 columns `label`, `value`, and `description` with one or more rows.

For example: For the red subbox (Female ~ TreatmentA) one could define three functions:

* One returning total population (`N=120`)
* One returning frequency with event (`n=18`)
* And lastly relative frequency (`(%)=15%`)

However, one could also have a single function returning all three as a single data.table with 3 rows.

**NB** Description is also the place to put information about a potential model you are including. You may have stat functions which uses different methods for obtaining p-values depending on data, you could then reflect the choice of method in the description.


### Input specifications and examples {.tabset}

Common for all functions are the `dat` (data in a `data.table::data.table`) and some `index_*` parameters.
The `index_*` points to a column in `dat` called `INDEX_` which the `dat` is also keyed by.
Therefore to obtain those rows 

#### stat_by_strata_by_trt

{chef} will always supply the following parameters to `stat_by_strata_by_trt` functions.
You must therefore either include them in the function definition or add ellipsis `...` to ignore them.


<table style = "width:100%; margin:20px; border-bottom: 2px solid #ddd;">
  <caption>*Input Specification*</caption>
  <colgroup>
    <col style="width:20%;">
    <col style="width:20%;">
    <col style="width:60%;">
  </colgroup>
    <thead>
      <td>Parameter</td>
      <td>Datatype</td>
      <td>Description</td>
    </thead>
    <tbody>
        <tr>
            <td>dat</td>
            <td>data.table</td>
            <td>datatable containing the full in-risk population.</td>
        </tr>
        <tr>
            <td>event_index</td>
            <td>list</td>
            <td>indexes (the `_INDEX_` column in data) of rows with an event.</td>
        </tr>
        <tr>
            <td>cell_index</td>
            <td>list</td>
            <td>indexes (the `_INDEX_` column in data) of rows matching the cell.*</td>
        </tr>
        <tr>
            <td>strata_var</td>
            <td>character</td>
            <td>Name of the column describing the strata.</td>
        </tr>
        <tr>
            <td>strata_val</td>
            <td>character\|numeric</td>
            <td>specific value or level for the strata.</td>
        </tr>
        <tr>
            <td>treatment_var</td>
            <td>character</td>
            <td>Name of the column describing the treatment.</td>
        </tr>
        <tr>
            <td>treatment_val</td>
            <td>character\|numeric</td>
            <td>specific value or level for the treatment.</td>
        </tr>
        <tr>
            <td>subjectid_var</td>
            <td>character</td>
            <td>Name of the column that has the subject id.</td>
        </tr>
    </tbody>
</table>

_* The cell_index will for instance point at those rows where SEX=M and Treatment=A _ 

*Example function*
```{r input_spec_trt_sbglevel, title="Example function", echo=T,eval=F, out.width="100%"}
# function to calculate total sub-population and those with events.
pop_frequency_with_events <- function(
    dat,
    event_index,
    cell_index,
    subjectid_var,
    ... #Note we wont use the extra supplied parameters so we pass them using dots.
    )
  
  # Total number in the sub-population. ie. Gender=Male, Treatment=A. data.table logic
  N <- dat[J(cell_index), .SD, .SDcols = (subject_id_var)] %>%
    data.table::uniqueN()

  n <- dat[
      J(intersect(event_index, cell_index)),
      .SD, .SDcols = (subject_id_var)
    ] %>%
    data.table::uniqueN()

  
  # Frequency of events in the sub-population in %
  n_f = (n / N) * 100
  
  # Prepare output.
  out = data.table::data.table(
    label = c("N", "n", "(%)"),
    value = c(N, n, n_f)
    description = c(
      "Subjects",
      "Subject with events",
      "Proportion of subjects with events."
    )
  )
  return(out)

```


#### stat_by_strata_across_trt

<table style = "width:100%; margin:20px; border-bottom: 2px solid #ddd;">
  <caption>*Input Specification*</caption>
  <colgroup>
    <col style="width:20%;">
    <col style="width:20%;">
    <col style="width:60%;">
  </colgroup>
    <thead>
      <td>Parameter</td>
      <td>Datatype</td>
      <td>Description</td>
    </thead>
    <tbody>
        <tr>
            <td>dat</td>
            <td>data.table</td>
            <td>datatable containing the full in-risk population.</td>
        </tr>
        <tr>
            <td>event_index</td>
            <td>list</td>
            <td>indexes (the `_INDEX_` column in data) of rows with an event.</td>
        </tr>
        <tr>
            <td>cell_index</td>
            <td>list</td>
            <td>indexes (the `_INDEX_` column in data) of rows matching the cell.*</td>
        </tr>
        <tr>
            <td>strata_var</td>
            <td>character</td>
            <td>Name of the column describing the strata</td>
        </tr>
        <tr>
            <td>strata_val</td>
            <td>character\|numeric</td>
            <td>specific value or level for the strata</td>
        </tr>
        <tr>
            <td>treatment_var</td>
            <td>character</td>
            <td>Name of the column describing the treatment.</td>
        </tr>
        <tr>
            <td>treatment_refval</td>
            <td>character\|numeric</td>
            <td>specific value or level for the treatment.</td>
        </tr>
        <tr>
            <td>subjectid_var</td>
            <td>character</td>
            <td>Name of the column that has the subject id.</td>
        </tr>
    </tbody>
</table>

_* Those rows where strata_var==strata_val (ie. Gender==Sex)_

*Example function*
```{r input_spec_sbglevel, title="Example function", echo=T,eval=F, out.width="100%"}
# contingency 2x2 table for total number of events 
contingency2x2_ptest <- function(
    dat,
    event_index,
    cell_index,
    treatment_var,
    ... #Note we wont use the extra supplied parameters so we pass them using dots.
    )
  
  # Test a 2x2 contingency table ie. is there a link between treatment and total number of events
  dat_cell <- dat[J(cell_index),]
  dat_cell[, is_event := INDEX_ %in% event_index]
  
  count_table <- dat_cell[, .SD, .SDcols = c("is_event", treatment_var)] %>%
    table()
  
  res <- fisher.test(
    count_table,
    conf.int=T
    )
  
  # Prepare output. since confidence interval is two values wrap it in a list.
  out = data.table::data.table(
    label = c("Pval_independency", "CI_upper", "CI_lower"),
    value = c(res$p.value, res$conf.int[1], res$conf.int[2]),
    description = "Fishers exact tests of independence of rows and columns in a contingency table."
  )
  return(out)

```

#### stat_across_strata_across_trt

<table style = "width:100%; margin:20px; border-bottom: 2px solid #ddd;">
  <caption>*Input Specification*</caption>
  <colgroup>
    <col style="width:20%;">
    <col style="width:20%;">
    <col style="width:60%;">
  </colgroup>
    <thead>
      <td>Parameter</td>
      <td>Datatype</td>
      <td>Description</td>
    </thead>
    <tbody>
        <tr>
            <td>dat</td>
            <td>data.table</td>
            <td>datatable containing the full in-risk population.</td>
        </tr>
        <tr>
            <td>event_index</td>
            <td>list</td>
            <td>indexes (the `_INDEX_` column in data) of rows with an event.</td>
        </tr>
        <tr>
            <td>strata_var</td>
            <td>character</td>
            <td>Name of the column describing the strata</td>
        </tr>
        <tr>
            <td>treatment_var</td>
            <td>character</td>
            <td>Name of the column describing the treatment.</td>
        </tr>
        <tr>
            <td>treatment_refval</td>
            <td>character\|numeric</td>
            <td>specific value or level for the treatment.</td>
        </tr>
        <tr>
            <td>subjectid_var</td>
            <td>character</td>
            <td>Name of the column that has the subject id.</td>
        </tr>
    </tbody>
</table>


```{r input_spec_sbg, title="Example function", echo=T,eval=F, out.width="100%"}
# Cochran-mante-haenszel test for odds ratios across strata
contingency2x2_strata_test <- function(
    dat,
    event_index,
    strata_var,
    treatment_var,
    subjectid_var,
    ... 
    )

  # Test a 2x2 contingency table ie. is there a link between treatment and patients with events 
  # over multiple strata (strata_var)
  dt_unique_subjects <- dat %>% 
    unique(by=subject_id_var)
  dt_unique_subjects[, is_event := INDEX_ %in% event_index]
  count_table <- dt_unique_subjects[
      , 
      .SD, 
      .SDcols = c("is_event", treatment_var, strata_var)
    ] %>%
    table()

  res <- stats::mantelhaen.test(
    cont_table,
    conf.int
    )
  
  # Prepare output.
  out = data.table::data.table(
    label = c("Pval_independency", "CI_lower", "CI_upper"),
    value = c(res$p.value, res$conf.int[[1]], res$conf.int[[2]]),
    description = "Cochran-mante-haenszel test for odds ratios across strata."
  )
  return(out)

```

## Adding new statistical methods in {chef}

Statistical methods can be supplied by multiple means:

### Use statistical functions defined in external packages

When using statistical methods from an external package you must include the import statement `library(ExternalPackage)` in the chef project `R/packages.R` file. See [chef setup](chef.html) for how to organize your project.

Unless the external library is made to work with {chef} you will likely need a wrapper function in order conform with the input and output specification of statistical functions in {chef}. Similar to the use case above for the `contingency2x2_strata_test` function.


### Use of custom statistical functions

You may also defined statistical functions from scratch to use in the pipeline. 
Then simply defined the function in a `R/SomeFileWithStatFunctions.R` and apply them as described in below section *Using statistical methods in endpoints*

## Applying statistical methods in endpoints.

Statistical methods are supplied to chef via the ``mk_endpoint_str` function. 
The function has 3 parameters one for each of the function types: (`stat_by_strata_by_trt`, `stat_by_strata_across_trt`, `stat_across_strata_across_trt`).
The parameters takes a named list of one or more statistical functions and any optional parameters you wish to pass.

An input could look like:

```{r, eval=F}

mk_endpoint_def <- function() {
  mk_endpoint_str(
                ..., #Other inputs
                stat_by_strata_by_trt = list(pop_frequency_with_events)
              )

# Or adding a custom name
mk_endpoint_def <- function() {
  mk_endpoint_str(
                ..., #Other inputs
                stat_by_strata_by_trt = list("pop_freq_events" = pop_frequency_with_events)
              )
}

# It may also be that you want to add a parameter to the statistical function. (fictional in this case)
mk_endpoint_def <- function() {
  mk_endpoint_str(
                ..., #Other inputs
                stat_by_strata_by_trt = list(
                  "pop_freq_events_with_na" = c(pop_frequency_with_events, keep.na=TRUE))
              )
}
```

By adding extra parameters to your functions you have extra flexibility in designing your statistical functions without having to define multiple functions having almost the same functionality.


### Custom functions, currying, and supplying parameters.

The framework allows a high degree of flexibility in supplying statistical functions, only specifying inputs and outputs. Therefore, one may be tempted to add functions with a lot of parameters that is then added during the setup of endpoints using the `mk_endpoint_str` function.

However, we urge that you create partialised or curried functions and define the in `R/statistical_functions.R` and then call them using the simplified calls in `mk_endpoint_str`. The motivation for this proposal is ease of debugging and easy to read endpoints.


#### A toy example showcasing the use of currying.

Imagine that stats4chef package contains the following function.

```{r}
chef_percentiles <- function(
  dat,
  cell_index,
  target_column,
  percentile,
  type = 7,
  ...
){
  
  label = paste0("Percentile(", percentile, ")")
  vals = dat[J(cell_index), .SD, .SDcols = c(target_column)]
  q = stats::quantile(vals, probs = percentile, type=type)
  
  out = data.table::data.table(
    label = label,
    value = q
  )
  return(out)
}

```

Then one could use it directly to get the median of age in a given stratum and treatment arm as:

```{r,eval=F}
mk_endpoint_def <- function() {
  mk_endpoint_str(
                ..., #Other inputs
                stat_by_strata_by_trt = list(
                  "median_age" = c(
                    stats4chef::chef_percentiles,
                    target_column = "AGE",
                    percentile = 0.5))
              )
}
```
*However, that quickly becomes quite hard to read.*

---

The suggested approach would therefor be to curry the function.

When currying you set a number of the parameters before executing the function.
We suggest using the `purrr` package, however you can also create a wrapper function instead.


In the project have a file `R/specified_stats.R`
```{r, eval=F}
library(stats4chef)
library(purrr)

#Recommended
median_age <- purrr::partial(
  stats4chef::chef_percentiles,
  target_column = "AGE",
  percentile = 0.5
)

#Alternative (Not recommended)
median_age <- function(
    dat,
    cell_index,
    ...
){
  return(
    stats4chef::chef_percentiles(
      dat = dat,
      target_column = "AGE",
      percentile = 0.5
    )
  )
}


```

Which can then be used in the end point definition as:

Allowing a much cleaner endpoint definition.

```{r,eval=F}
mk_endpoint_def <- function() {
  mk_endpoint_str(
                ..., #Other inputs
                stat_by_strata_by_trt = list(median_age)
              )
}
```
